# -*- coding: utf-8 -*-
"""data_preparation_functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TgmGeG_8m8zNGBrJQotPJhuYud8MMK3X
"""

import pandas as pd

def filter_by_city(path, city):
  df = pd.read_csv(path)
  df = df[df['city'] == city]

  return df

# HELPER FUNCTIONS

def categorize_location(df):
  # Approximate conversion factors
  LATITUDE_TO_METERS = 111_111  # 1 degree latitude in meters
  LONGITUDE_TO_METERS = 111_111 * np.cos(np.radians(50))  # Adjust for latitude
  GRID_SIZE_METERS = 1_000  # 1 km grid size

  # Convert latitude and longitude to grid indices
  df['lat_index'] = (df['latitude'] * LATITUDE_TO_METERS // GRID_SIZE_METERS).astype(int)
  df['lon_index'] = (df['longitude'] * LONGITUDE_TO_METERS // GRID_SIZE_METERS).astype(int)

  # Combine grid indices into a category
  df['locationCategory'] = df['lat_index'].astype(str) + "_" + df['lon_index'].astype(str)

  # Encode location categories to numbers
  df['locationCategory'] = pd.factorize(df['locationCategory'])[0] + 1  # Start encoding from 1

  # Drop columns that are no longer necessary
  df = df.drop(columns=['latitude', 'longitude','lat_index', 'lon_index'])

  return df



def fill_na_in_type(df):
    # Calculate global most popular type
  pop_type = df['type'].value_counts().idxmax()

  # Calculate most popular type within buildYear and locationCategory
  year_loc_type = (
      df.groupby(["buildYear", "locationCategory"])["type"]
      .apply(lambda x: x.mode().iloc[0] if not x.mode().empty else None)
      .reset_index(name="dominant_type")
  )

  # Calculate most popular type within locationCategory
  loc_type = (
      df.groupby("locationCategory")["type"]
      .apply(lambda x: x.mode().iloc[0] if not x.mode().empty else None)
      .to_dict()
  )

  # Merge with the original DataFrame using year_loc_type
  df_merged = df.merge(year_loc_type, on=["buildYear", "locationCategory"], how="left")

  # Fill missing 'dominant_type' with locationCategory mapping
  df_merged["dominant_type"] = df_merged["dominant_type"].fillna(df_merged["locationCategory"].map(loc_type))

  # Fill final missing values with the global most popular type
  df_merged["dominant_type"] = df_merged["dominant_type"].fillna(pop_type)

  # # Fill missing values in original DataFrame using new column
  df = df.reset_index(drop=True)  # Reset index to align
  df_merged = df_merged.reset_index(drop=True)
  df['type'] = df['type'].fillna(df_merged['dominant_type'])

  return df


#  MAIN FUNCTION

def prepare_data(dataframe):

  # Categorize location
  df = categorize_location(dataframe)
  # Create a column for price per square meter
  df['price_per_m2'] = (df['price'] / df['squareMeters']).round(0)

  # FILL MISSING VALUES
  df = fill_na_in_type(df)

  df["buildYear"] = df.groupby("type")["buildYear"].transform(
    lambda x: x.fillna(round(x.median())))

  df['buildingMaterial'] = df['buildingMaterial'].fillna('other')

  df['floorCount'] = df['floorCount'].fillna(round(df['floorCount'].median()))

  df['condition'] = df['condition'].fillna('standard')

  df['floor'] = df.groupby('floorCount')['floor'].transform(
    lambda x: x.fillna(x.mode().iloc[0] if not x.mode().empty else 1))


  return df